From ab4c4f15cfb220d46e494cbc9720b46b65eeb022 Mon Sep 17 00:00:00 2001
From: Catherine Garabedian <catherine@kubos.co>
Date: Wed, 6 Sep 2017 16:26:45 -0500
Subject: [PATCH 1/2] Creating SD switching application

---
 examples/standalone/AT91SAM9G20.h | 113 ++++++++++++++++
 examples/standalone/iobc_set_sd.c | 268 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 381 insertions(+)
 create mode 100644 examples/standalone/AT91SAM9G20.h
 create mode 100644 examples/standalone/iobc_set_sd.c

diff --git a/examples/standalone/AT91SAM9G20.h b/examples/standalone/AT91SAM9G20.h
new file mode 100644
index 0000000000..1f002b6223
--- /dev/null
+++ b/examples/standalone/AT91SAM9G20.h
@@ -0,0 +1,113 @@
+//  ----------------------------------------------------------------------------
+//          ATMEL Microcontroller Software Support  -  ROUSSET  -
+//  ----------------------------------------------------------------------------
+//  Copyright (c) 2008, Atmel Corporation
+//
+//  All rights reserved.
+//
+//  Redistribution and use in source and binary forms, with or without
+//  modification, are permitted provided that the following conditions are met:
+//
+//  - Redistributions of source code must retain the above copyright notice,
+//  this list of conditions and the disclaimer below.
+//
+//  Atmel's name may not be used to endorse or promote products derived from
+//  this software without specific prior written permission.
+//
+//  DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+//  DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//  ----------------------------------------------------------------------------
+// File Name           : AT91SAM9G20.h
+// Object              : AT91SAM9G20 definitions
+// Generated           : AT91 SW Application Group  12/08/2008 (14:42:59)
+//
+// CVS Reference       : /AT91SAM9G20.pl/1.3/Tue Nov  4 12:33:41 2008//
+// CVS Reference       : /SYS_SAM9260.pl/1.3/Fri Feb 29 14:02:57 2008//
+// CVS Reference       : /HMATRIX1_SAM9260.pl/1.7/Wed Apr 25 16:48:51 2007//
+// CVS Reference       : /CCR_SAM9260.pl/1.2/Wed Feb 21 17:28:50 2007//
+// CVS Reference       : /PMC_SAM9260.pl/1.2/Thu Oct 13 11:39:15 2005//
+// CVS Reference       : /ADC_9260.pl/1.2/Thu Dec  7 14:16:26 2006//
+// CVS Reference       : /HSDRAMC1_6100A.pl/1.2/Mon Aug  9 10:52:25 2004//
+// CVS Reference       : /HSMC3_6105A.pl/1.5/Thu Jun  5 15:27:27 2008//
+// CVS Reference       : /AIC_6075A.pl/1.1/Mon Jul 12 17:04:01 2004//
+// CVS Reference       : /PDC_6074C.pl/1.2/Thu Feb  3 09:02:11 2005//
+// CVS Reference       : /DBGU_6059D.pl/1.1/Mon Jan 31 13:54:41 2005//
+// CVS Reference       : /PIO_6057A.pl/1.2/Thu Feb  3 10:29:42 2005//
+// CVS Reference       : /RSTC_6098A.pl/1.4/Fri Oct 17 13:27:55 2008//
+// CVS Reference       : /SHDWC_6122A.pl/1.3/Wed Oct  6 14:16:58 2004//
+// CVS Reference       : /RTTC_6081A.pl/1.2/Thu Nov  4 13:57:22 2004//
+// CVS Reference       : /PITC_6079A.pl/1.2/Thu Nov  4 13:56:22 2004//
+// CVS Reference       : /WDTC_6080A.pl/1.3/Thu Nov  4 13:58:52 2004//
+// CVS Reference       : /TC_6082A.pl/1.8/Fri Oct 17 13:27:58 2008//
+// CVS Reference       : /MCI_6101E.pl/1.1/Fri Jun  3 13:20:23 2005//
+// CVS Reference       : /TWI_6061B.pl/1.3/Fri Oct 17 13:27:59 2008//
+// CVS Reference       : /US_6089C.pl/1.1/Mon Jan 31 13:56:02 2005//
+// CVS Reference       : /SSC_6078A.pl/1.1/Tue Jul 13 07:10:41 2004//
+// CVS Reference       : /SPI_6088D.pl/1.3/Fri May 20 14:23:02 2005//
+// CVS Reference       : /EMACB_6119A.pl/1.6/Wed Jul 13 15:25:00 2005//
+// CVS Reference       : /UDP_6ept_puon.pl/1.1/Thu Aug  3 12:46:31 2006//
+// CVS Reference       : /UHP_6127A.pl/1.1/Wed Feb 23 16:03:17 2005//
+// CVS Reference       : /TBOX_XXXX.pl/1.15/Thu Jun  9 07:05:57 2005//
+// CVS Reference       : /EBI_SAM9260.pl/1.1/Fri Sep 30 12:12:14 2005//
+// CVS Reference       : /HECC_6143A.pl/1.1/Wed Feb  9 17:16:57 2005//
+// CVS Reference       : /ISI_xxxxx.pl/1.6/Mon Sep  1 14:41:33 2008//
+//  ----------------------------------------------------------------------------
+
+#ifndef AT91SAM9G20_H
+#define AT91SAM9G20_H
+
+typedef volatile unsigned int AT91_REG;// Hardware register definition
+#define AT91_CAST(a) (a)
+
+// *****************************************************************************
+//              SOFTWARE API DEFINITION  FOR Parallel Input Output Controller
+// *****************************************************************************
+typedef struct _AT91S_PIO {
+	AT91_REG	 PIO_PER; 	// PIO Enable Register
+	AT91_REG	 PIO_PDR; 	// PIO Disable Register
+	AT91_REG	 PIO_PSR; 	// PIO Status Register
+	AT91_REG	 Reserved0[1]; 	//
+	AT91_REG	 PIO_OER; 	// Output Enable Register
+	AT91_REG	 PIO_ODR; 	// Output Disable Register
+	AT91_REG	 PIO_OSR; 	// Output Status Register
+	AT91_REG	 Reserved1[1]; 	//
+	AT91_REG	 PIO_IFER; 	// Input Filter Enable Register
+	AT91_REG	 PIO_IFDR; 	// Input Filter Disable Register
+	AT91_REG	 PIO_IFSR; 	// Input Filter Status Register
+	AT91_REG	 Reserved2[1]; 	//
+	AT91_REG	 PIO_SODR; 	// Set Output Data Register
+	AT91_REG	 PIO_CODR; 	// Clear Output Data Register
+	AT91_REG	 PIO_ODSR; 	// Output Data Status Register
+	AT91_REG	 PIO_PDSR; 	// Pin Data Status Register
+	AT91_REG	 PIO_IER; 	// Interrupt Enable Register
+	AT91_REG	 PIO_IDR; 	// Interrupt Disable Register
+	AT91_REG	 PIO_IMR; 	// Interrupt Mask Register
+	AT91_REG	 PIO_ISR; 	// Interrupt Status Register
+	AT91_REG	 PIO_MDER; 	// Multi-driver Enable Register
+	AT91_REG	 PIO_MDDR; 	// Multi-driver Disable Register
+	AT91_REG	 PIO_MDSR; 	// Multi-driver Status Register
+	AT91_REG	 Reserved3[1]; 	//
+	AT91_REG	 PIO_PPUDR; 	// Pull-up Disable Register
+	AT91_REG	 PIO_PPUER; 	// Pull-up Enable Register
+	AT91_REG	 PIO_PPUSR; 	// Pull-up Status Register
+	AT91_REG	 Reserved4[1]; 	//
+	AT91_REG	 PIO_ASR; 	// Select A Register
+	AT91_REG	 PIO_BSR; 	// Select B Register
+	AT91_REG	 PIO_ABSR; 	// AB Select Status Register
+	AT91_REG	 Reserved5[9]; 	//
+	AT91_REG	 PIO_OWER; 	// Output Write Enable Register
+	AT91_REG	 PIO_OWDR; 	// Output Write Disable Register
+	AT91_REG	 PIO_OWSR; 	// Output Write Status Register
+} AT91S_PIO, *AT91PS_PIO;
+
+#define AT91C_BASE_PIOB      (AT91_CAST(AT91PS_PIO) 	0xFFFFF600) // (PIOB) Base Address
+
+#endif
diff --git a/examples/standalone/iobc_set_sd.c b/examples/standalone/iobc_set_sd.c
new file mode 100644
index 0000000000..5d59e1cbab
--- /dev/null
+++ b/examples/standalone/iobc_set_sd.c
@@ -0,0 +1,268 @@
+/*
+* Copyright (C) 2017 Kubos Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* This program is intended to be compiled and run as a standalone U-Boot
+* binary in compliance with their GPL exception.
+*/
+
+#include <common.h>
+#include <exports.h>
+#include <spi.h>
+#include "AT91SAM9G20.h"
+
+#define BUS 0
+#define CS 0
+#define MAX_SPEED 40000000
+#define MODE SPI_MODE_0
+
+struct spi_slave * fram;
+
+int8_t fram_open(void);
+void   fram_close(void);
+int8_t fram_readSD(uint8_t * sd_byte);
+void fram_writeSD(uint8_t sd_byte);
+int8_t fram_protect(void);
+void sd_verify(uint8_t * sd_byte);
+void set_gpio(uint32_t mask);
+
+/* THIS FUNCTION BETTER BE FIRST. DON'T YOU DARE MOVE IT */
+int8_t iobc_set_sd(int8_t argc, char * const argv[])
+{
+    /* Load the U-Boot jump table */
+    app_startup(argv);
+
+    /*
+     * Check the ABI version. It's unlikely to change, but if it does, we'll
+     * need to manually check for incompatibilities.
+     */
+    if (XF_VERSION != get_version())
+    {
+        printf("ABI version mismatch: %d vs %lu\n", XF_VERSION, get_version());
+        return -1;
+    }
+
+    if (fram_open() < 0)
+    {
+        return -2;
+    }
+
+    uint8_t sd_byte = 0;
+
+    if (fram_readSD(&sd_byte) < 0)
+    {
+        debug("Error reading SD byte. Using default SD card\n");
+        sd_byte = 0;
+    }
+
+    sd_verify(&sd_byte);
+
+    if (sd_byte == 1)
+    {
+        /* Set the SD select pin */
+        set_gpio(1 << 16);
+
+        /* Turn on the SD1 power pin */
+        set_gpio(1 << 7);
+    }
+    else
+    {
+        /* Turn on the SD0 power pin */
+        set_gpio(1 << 6);
+    }
+
+    fram_protect();
+
+    fram_close();
+
+    return 0;
+}
+
+int8_t fram_open(void)
+{
+    fram = spi_setup_slave(BUS, CS, MAX_SPEED, MODE);
+    if (!fram)
+    {
+        puts("Unable to setup FRAM\n");
+        return -1;
+    }
+
+    if (spi_claim_bus(fram))
+    {
+        puts("Unable to claim SPI bus\n");
+        spi_free_slave(fram);
+        return -1;
+    }
+
+    return 0;
+}
+
+void fram_close(void)
+{
+    spi_release_bus(fram);
+    spi_free_slave(fram);
+    return;
+}
+
+/* Read the sd_byte value from FRAM */
+int8_t fram_readSD(uint8_t * sd_byte)
+{
+    /* Read: 0x03, Addr: 0x030000, 1 read byte */
+    char buf[5] = { 0 };
+    buf[0]      = 0x03;
+    buf[1]      = 0x03;
+
+    /* The BEGIN/END flags tell U-Boot to do the CS work for us */
+    if (spi_xfer(fram, 8 * sizeof(buf), buf, buf, SPI_XFER_BEGIN | SPI_XFER_END)
+        != 0)
+    {
+        puts("Read: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return -1;
+    }
+
+    *sd_byte = buf[4];
+
+    return 0;
+}
+
+uint8_t count_ones(uint8_t byte)
+{
+    static const uint8_t NIBBLE_LOOKUP[16]
+        = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
+
+    return NIBBLE_LOOKUP[byte & 0x0F] + NIBBLE_LOOKUP[byte >> 4];
+}
+
+/*
+ * sd_verify
+ *
+ * This function will examine the read sd_byte value.
+ * Ideally the byte will be either all 1's or 0's, but space is a dangerous
+ * place, so some bits might have gotten flipped.
+ * If the value is mostly 1's, then we'll write 0xFF back into storage and use
+ * SD slot 0. Otherwise, we'll write 0x00 and use SD slot 0.
+ */
+void sd_verify(uint8_t * sd_byte)
+{
+    uint8_t ones = count_ones(*sd_byte);
+
+    *sd_byte = 0;
+
+    if (ones > 4)
+    {
+        *sd_byte = 1;
+        if (ones != 8)
+        {
+            fram_writeSD(0xFF);
+        }
+    }
+    else
+    {
+        if (ones == 4)
+        {
+            puts("Unable to determine SD slot value. Using default SD card\n");
+        }
+        if (ones != 0)
+        {
+            fram_writeSD(0);
+        }
+    }
+}
+
+/* Write the sd_byte value to FRAM */
+void fram_writeSD(uint8_t sd_byte)
+{
+    /* Enable writes (this includes the status register */
+    char wren = 0x06;
+    if (spi_xfer(fram, 8, &wren, &wren, SPI_XFER_BEGIN | SPI_XFER_END) != 0)
+    {
+        puts("WREN: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return;
+    }
+
+    /* WRSR: 0x01, Value: Turn off write protection */
+    char wrsr_buf[2];
+    wrsr_buf[0] = 0x01;
+    wrsr_buf[1] = 0x00;
+
+    if (spi_xfer(fram, 8 * sizeof(wrsr_buf), wrsr_buf, wrsr_buf, SPI_XFER_BEGIN | SPI_XFER_END)
+        != 0)
+    {
+        puts("WRSR: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return;
+    }
+
+    /* Enable writes (this includes the status register */
+    wren = 0x06;
+    if (spi_xfer(fram, 8, &wren, &wren, SPI_XFER_BEGIN | SPI_XFER_END) != 0)
+    {
+        puts("WREN: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return;
+    }
+
+    /* Write: 0x02, Addr: 0x030000, 1 data byte */
+    char write_buf[5] = { 0 };
+    write_buf[0]      = 0x02;
+    write_buf[1]      = 0x03;
+    write_buf[4]      = sd_byte;
+
+    /* The BEGIN/END flags tell U-Boot to do the CS work for us */
+    if (spi_xfer(fram, 8 * sizeof(write_buf), write_buf, write_buf, SPI_XFER_BEGIN | SPI_XFER_END)
+        != 0)
+    {
+        puts("Read: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return;
+    }
+
+    return;
+}
+
+/* Make sure our data area is protected from users */
+int8_t fram_protect(void)
+{
+    /* Enable writes (this includes the status register */
+    char wren = 0x06;
+    if (spi_xfer(fram, 8, &wren, &wren, SPI_XFER_BEGIN | SPI_XFER_END) != 0)
+    {
+        puts("WREN: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return -1;
+    }
+
+    /* WRSR: 0x01, Value: Protect upper 1/4 */
+    char buf[2];
+    buf[0] = 0x01;
+    buf[1] = 0x04;
+
+    if (spi_xfer(fram, 8 * sizeof(buf), buf, buf, SPI_XFER_BEGIN | SPI_XFER_END)
+        != 0)
+    {
+        puts("WRSR: Hit ATMEL_SPI_SR_OVRES error state\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/* Turn on the requested GPIO */
+void set_gpio(uint32_t mask)
+{
+
+    AT91PS_PIO pio = AT91C_BASE_PIOB;
+
+    pio->PIO_IDR   = mask;
+    pio->PIO_PPUDR = mask;
+    pio->PIO_CODR  = mask;
+    pio->PIO_OER   = mask;
+    pio->PIO_PER   = mask;
+}
-- 
2.12.2.windows.2


From 6d74ea6e54473449f23a5b07d039f45382129e5f Mon Sep 17 00:00:00 2001
From: Catherine Garabedian <catherine@kubos.co>
Date: Wed, 13 Sep 2017 12:06:10 -0500
Subject: [PATCH 2/2] Allowing the caller to specify the slot to use

---
 examples/standalone/iobc_set_sd.c | 35 +++++++++++++++++++++++++++++++----
 1 file changed, 31 insertions(+), 4 deletions(-)

diff --git a/examples/standalone/iobc_set_sd.c b/examples/standalone/iobc_set_sd.c
index 5d59e1cbab..9c74873c4c 100644
--- a/examples/standalone/iobc_set_sd.c
+++ b/examples/standalone/iobc_set_sd.c
@@ -35,6 +35,7 @@ int8_t fram_readSD(uint8_t * sd_byte);
 void fram_writeSD(uint8_t sd_byte);
 int8_t fram_protect(void);
 void sd_verify(uint8_t * sd_byte);
+void clear_gpio(uint32_t mask);
 void set_gpio(uint32_t mask);
 
 /* THIS FUNCTION BETTER BE FIRST. DON'T YOU DARE MOVE IT */
@@ -60,10 +61,22 @@ int8_t iobc_set_sd(int8_t argc, char * const argv[])
 
     uint8_t sd_byte = 0;
 
-    if (fram_readSD(&sd_byte) < 0)
+    if (argc == 1)
     {
-        debug("Error reading SD byte. Using default SD card\n");
-        sd_byte = 0;
+        if (fram_readSD(&sd_byte) < 0)
+        {
+            debug("Error reading SD byte. Using default SD card\n");
+            sd_byte = 0;
+        }
+    }
+    else
+    {
+        sd_byte = (uint8_t) strtoul(argv[1], NULL, 0);
+
+        /* Clear any previously set pins, since it's possible we already did MMC setup */
+        clear_gpio(1 << 16);
+        clear_gpio(1 << 7);
+        clear_gpio(1 << 6);
     }
 
     sd_verify(&sd_byte);
@@ -86,7 +99,7 @@ int8_t iobc_set_sd(int8_t argc, char * const argv[])
 
     fram_close();
 
-    return 0;
+    return sd_byte;
 }
 
 int8_t fram_open(void)
@@ -254,6 +267,20 @@ int8_t fram_protect(void)
     return 0;
 }
 
+/* Turn off the requested GPIO */
+void clear_gpio(uint32_t mask)
+{
+
+    AT91PS_PIO pio = AT91C_BASE_PIOB;
+
+    pio->PIO_IDR   = mask;
+    pio->PIO_PPUDR = mask;
+    pio->PIO_SODR  = mask;
+    pio->PIO_OER   = mask;
+    pio->PIO_PER   = mask;
+}
+
+
 /* Turn on the requested GPIO */
 void set_gpio(uint32_t mask)
 {
-- 
2.12.2.windows.2

